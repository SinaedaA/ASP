#!/bin/bash

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([join-method],[m],[Method for joining reads (default: DADA2, others: FLASH2, vsearch, deblur)],[DADA2])
# ARG_OPTIONAL_SINGLE([trim-left-f],[],[Position at which FORWARD read sequences should be trimmed due to low quality. This trims the 5' end of the input sequences, which will be the bases that were sequenced in the first cycles.],[0])
# ARG_OPTIONAL_SINGLE([trim-left-r],[],[Position at which REVERSE read sequences should be trimmed due to low quality. This trims the 5' end of the input sequences, which will be the bases that were sequenced in the first cycles.],[0])
# ARG_OPTIONAL_SINGLE([trunc-len-f],[],[Position at which FORWARD read sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles.],[0])
# ARG_OPTIONAL_SINGLE([trunc-len-r],[],[Position at which REVERSE read sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles.],[0])
# ARG_OPTIONAL_SINGLE([overlap],[o],[Mininum overlap for joining reads],[12])
# ARG_POSITIONAL_SINGLE([qza],[Path to trimmed sequences.qza file to input for joining and denoising])
# ARG_DEFAULTS_POS()
# ARG_HELP([<Joining and denoising of paired end reads. Joining method can be chosen (DADA2, FLASH2, vsearch), denoising is always done with DADA2.>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='moh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_qza=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_join_method="DADA2"
_arg_trim_left_f="0"
_arg_trim_left_r="0"
_arg_trunc_len_f="0"
_arg_trunc_len_r="0"
_arg_overlap="12"


print_help()
{
	printf '%s\n' "<Joining and denoising of paired end reads. Joining method can be chosen (DADA2, FLASH2, vsearch), denoising is always done with DADA2.>"
	printf 'Usage: %s [-m|--join-method <arg>] [--trim-left-f <arg>] [--trim-left-r <arg>] [--trunc-len-f <arg>] [--trunc-len-r <arg>] [-o|--overlap <arg>] [-h|--help] <qza>\n' "$0"
	printf '\t%s\n' "<qza>: Path to trimmed sequences.qza file to input for joining and denoising"
	printf '\t%s\n' "-m, --join-method: Method for joining reads (default: DADA2, others: FLASH2, vsearch, deblur) (default: 'DADA2')"
	printf '\t%s\n' "--trim-left-f: Position at which FORWARD read sequences should be trimmed due to low quality. This trims the 5' end of the input sequences, which will be the bases that were sequenced in the first cycles. (default: '0')"
	printf '\t%s\n' "--trim-left-r: Position at which REVERSE read sequences should be trimmed due to low quality. This trims the 5' end of the input sequences, which will be the bases that were sequenced in the first cycles. (default: '0')"
	printf '\t%s\n' "--trunc-len-f: Position at which FORWARD read sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles. (default: '0')"
	printf '\t%s\n' "--trunc-len-r: Position at which REVERSE read sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles. (default: '0')"
	printf '\t%s\n' "-o, --overlap: Mininum overlap for joining reads (default: '12')"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-m|--join-method)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_join_method="$2"
				shift
				;;
			--join-method=*)
				_arg_join_method="${_key##--join-method=}"
				;;
			-m*)
				_arg_join_method="${_key##-m}"
				;;
			--trim-left-f)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_trim_left_f="$2"
				shift
				;;
			--trim-left-f=*)
				_arg_trim_left_f="${_key##--trim-left-f=}"
				;;
			--trim-left-r)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_trim_left_r="$2"
				shift
				;;
			--trim-left-r=*)
				_arg_trim_left_r="${_key##--trim-left-r=}"
				;;
			--trunc-len-f)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_trunc_len_f="$2"
				shift
				;;
			--trunc-len-f=*)
				_arg_trunc_len_f="${_key##--trunc-len-f=}"
				;;
			--trunc-len-r)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_trunc_len_r="$2"
				shift
				;;
			--trunc-len-r=*)
				_arg_trunc_len_r="${_key##--trunc-len-r=}"
				;;
			-o|--overlap)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_overlap="$2"
				shift
				;;
			--overlap=*)
				_arg_overlap="${_key##--overlap=}"
				;;
			-o*)
				_arg_overlap="${_key##-o}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'qza'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_qza "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# vvv  PLACE YOUR CODE HERE  vvv
### Code written by Concetta Quattro and Sinaeda Anderssen
### Contact <cquattro@uni-koeln.de> <sanders2@uni-koeln.de>

### Declaring input variables
METHOD=$_arg_join_method
OVERLAP=$_arg_overlap
SEQ=$_arg_qza
TRIM_LEFT_F=$_arg_trim_left_f
TRIM_LEFT_R=$_arg_trim_left_r
TRUNC_LEN_F=$_arg_trunc_len_f
TRUNC_LEN_R=$_arg_trunc_len_r
OUTDIR="3_analysis"

### See which join method has been chosen
if [[ $METHOD == "DADA2" ]]
then
    ## Do denoising with DADA2 on paired-end data
    echo "Using DADA2 method to join AND denoise sequencing reads"
	mkdir $OUTDIR/DADA2_join_denoise/
    qiime dada2 denoise-paired \
        --i-demultiplexed-seqs $SEQ \
        --p-trim-left-f $TRIM_LEFT_F --p-trim-left-r $TRIM_LEFT_R --p-trunc-len-f $TRUNC_LEN_F --p-trunc-len-r $TRUNC_LEN_R \
        --o-table $OUTDIR/DADA2_join_denoise/table.qza --o-representative-sequences $OUTDIR/DADA2_join_denoise/rep-seqs.qza --o-denoising-stats $OUTDIR/DADA2_join_denoise/denoising-stats.qza \
        --p-n-threads 0 \
        --verbose
    qiime feature-table summarize \
        --i-table $OUTDIR/DADA2_join_denoise/table.qza \
        --o-visualization $OUTDIR/DADA2_join_denoise/table.qzv \
        --m-sample-metadata-file sample-metadata.tsv
    qiime feature-table tabulate-seqs \
        --i-data $OUTDIR/DADA2_join_denoise/rep-seqs.qza \
        --o-visualization $OUTDIR/DADA2_join_denoise/rep-seqs.qzv
    qiime metadata tabulate \
        --m-input-file $OUTDIR/DADA2_join_denoise/denoising-stats.qza \
        --o-visualization $OUTDIR/DADA2_join_denoise/denoising-stats.qzv
elif [[ $METHOD == "FLASH2" ]]
then
    ## Use FLASH2 to join reads, THEN DADA2 to denoise (single-end mode)
    echo "Using FLASH2 to join reads, followed by DADA2 to denoise in single-end mode"
	mkdir -p $OUTDIR/FLASH2_DADA2/TrimmedSequences/
    mkdir -p $OUTDIR/FLASH2_DADA2/JoinedReads/
    mkdir -p $OUTDIR/FLASH2_DADA2/DenoisedReads/
    command -v flash2 >/dev/null 2>&1 || { echo -e >&2 "I require flash2 but it's not installed in your environment. \nTry installing it with conda: 'conda install -c bioconda flash2'.  Aborting."; exit 1; }
    # ### Exporting trimmed sequences
    # qiime tools export \
    #     --input-path 3_analysis/TrimmedSequences/sequences_trimmed1.qza \
    #     --output-path $OUTDIR/FLASH2_DADA2/TrimmedSequences/
    ### Loop over samples to perform flash2 on R1 and R2
    for i in `cat sample-metadata.tsv | cut -f1`; do
        #change Phred-offset to variable at some point
        flash2 \
            --phred-offset=33 \
            --min-overlap=$OVERLAP \
            --max-overlap=300 \
            --compress $i*R1_001.fastq.gz $i*R2_001.fastq.gz \
            --output-directory=$OUTDIR/FLASH2_DADA2/JoinedReads/ \
            --output-prefix=$i 2>&1 | tee flash.log
    done
    ### Re-do steps 2 and 3 (make manifest and import data into QIIME)
    ../scripts/2_make_manifest.sh sample-metadata.tsv $OUTDIR/FLASH2_DADA2/JoinedReads/ \
        --outdir $OUTDIR/FLASH2_DADA2/2_manifest/
    ../scripts/3_import_seq_data.sh $OUTDIR/FLASH2_DADA2/2_manifest/manifest.tsv \
        --type single-end \
        --outdir $OUTDIR/FLASH2_DADA2/3_analysis/
    ### Then DADA2 denoising, single-end
    qiime dada2 denoise-single \
        --i-demultiplexed-seqs $SEQ \
        --p-trim-left-f $TRIM_LEFT_F --p-trim-left-r $TRIM_LEFT_R --p-trunc-len-f $TRUNC_LEN_F --p-trunc-len-r $TRUNC_LEN_R \
        --o-table $OUTDIR/FLASH2_DADA2/DenoisedReads/table.qza --o-representative-sequences $OUTDIR/FLASH2_DADA2/DenoisedReads/rep-seqs.qza --o-denoising-stats $OUTDIR/FLASH2_DADA2/DenoisedReads/denoising-stats.qza \
        --p-n-threads 0 \
        --verbose
    qiime feature-table summarize \
        --i-table $OUTDIR/FLASH2_DADA2/DenoisedReads/table.qza \
        --o-visualization $OUTDIR/FLASH2_DADA2/DenoisedReads/table.qzv \
        --m-sample-metadata-file sample-metadata.tsv
    qiime feature-table tabulate-seqs \
        --i-data $OUTDIR/FLASH2_DADA2/DenoisedReads/rep-seqs.qza \
        --o-visualization $OUTDIR/FLASH2_DADA2/DenoisedReads/rep-seqs.qzv
    qiime metadata tabulate \
        --m-input-file $OUTDIR/FLASH2_DADA2/DenoisedReads/denoising-stats.qza \
        --o-visualization $OUTDIR/FLASH2_DADA2/DenoisedReads/denoising-stats.qzv

elif [[ $METHOD == "vsearch" ]]; then
    mkdir $OUTDIR/vsearch_DADA2/
    ### join with vsearch, then quality filtering, then denoising with DADA2
else
    echo >&2 "Joining method not recognized, please try one of the following: DADA2, deblur, FLASH2, vsearch (case-sensitive)."; exit 1;
fi
# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
